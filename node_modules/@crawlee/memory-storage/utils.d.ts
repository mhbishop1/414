import type * as storage from '@crawlee/types';
/**
 * Removes all properties with a null value
 * from the provided object.
 */
export declare function purgeNullsFromObject<T>(object: T): T;
/**
 * Creates a standard request ID (same as Platform).
 */
export declare function uniqueKeyToRequestId(uniqueKey: string): string;
export declare function isBuffer(value: unknown): boolean;
export declare function isStream(value: any): boolean;
// @ts-ignore optional peer dependency or compatibility with es2022
export declare const memoryStorageLog: import("@apify/log").Log;
export type BackgroundHandlerReceivedMessage = BackgroundHandlerUpdateMetadataMessage;
export type BackgroundHandlerUpdateMetadataMessage = MetadataUpdate<'datasets', storage.DatasetInfo> | MetadataUpdate<'keyValueStores', storage.KeyValueStoreInfo> | MetadataUpdate<'requestQueues', storage.RequestQueueInfo>;
type EntityType = 'datasets' | 'keyValueStores' | 'requestQueues';
interface MetadataUpdate<Type extends EntityType, DataType> {
    entityType: Type;
    id: string;
    action: 'update-metadata';
    entityDirectory: string;
    data: DataType;
    writeMetadata: boolean;
    persistStorage: boolean;
}
/**
 * Creates a hybrid Promise + AsyncIterable for offset-based pagination (Dataset.listItems).
 *
 * The returned object can be:
 * - Awaited directly to get the first page (backward compatible)
 * - Used with `for await...of` to iterate through all items
 */
export declare function createPaginatedList<Data>(getPage: (offset: number, limit: number) => Promise<storage.PaginatedList<Data>>, options?: {
    offset?: number;
    limit?: number;
}): AsyncIterable<Data> & Promise<storage.PaginatedList<Data>>;
/**
 * Creates a hybrid Promise + AsyncIterable for cursor-based pagination (KeyValueStore.listKeys).
 *
 * The returned object can be:
 * - Awaited directly to get the first page (backward compatible)
 * - Used with `for await...of` to iterate through all keys
 */
export declare function createKeyList(getPage: (exclusiveStartKey?: string) => Promise<storage.KeyValueStoreClientListData>, options?: {
    exclusiveStartKey?: string;
    limit?: number;
}): AsyncIterable<storage.KeyValueStoreItemData> & Promise<storage.KeyValueStoreClientListData>;
/**
 * Creates a hybrid Promise + AsyncIterable that yields only key strings (KeyValueStore.keys).
 *
 * The returned object can be:
 * - Awaited directly to get the first page (backward compatible)
 * - Used with `for await...of` to iterate through all key strings
 */
export declare function createKeyStringList(getPage: (exclusiveStartKey?: string) => Promise<storage.KeyValueStoreClientListData>, options?: {
    exclusiveStartKey?: string;
    limit?: number;
}): AsyncIterable<string> & Promise<storage.KeyValueStoreClientListData>;
/**
 * Creates a hybrid Promise + AsyncIterable for offset-based pagination with index-value entries (Dataset.listEntries).
 *
 * The returned object can be:
 * - Awaited directly to get the first page with [index, item] tuples (backward compatible)
 * - Used with `for await...of` to iterate through all entries as [index, item] tuples
 */
export declare function createPaginatedEntryList<Data>(getPage: (offset: number, limit: number) => Promise<storage.PaginatedList<Data>>, options?: {
    offset?: number;
    limit?: number;
}): AsyncIterable<[number, Data]> & Promise<storage.PaginatedList<[number, Data]>>;
export {};
//# sourceMappingURL=utils.d.ts.map