"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.memoryStorageLog = void 0;
exports.purgeNullsFromObject = purgeNullsFromObject;
exports.uniqueKeyToRequestId = uniqueKeyToRequestId;
exports.isBuffer = isBuffer;
exports.isStream = isStream;
exports.createPaginatedList = createPaginatedList;
exports.createKeyList = createKeyList;
exports.createKeyStringList = createKeyStringList;
exports.createPaginatedEntryList = createPaginatedEntryList;
const tslib_1 = require("tslib");
const node_crypto_1 = require("node:crypto");
const shapeshift_1 = require("@sapphire/shapeshift");
const log_1 = tslib_1.__importDefault(require("@apify/log"));
const consts_1 = require("./consts");
/**
 * Removes all properties with a null value
 * from the provided object.
 */
function purgeNullsFromObject(object) {
    if (object && typeof object === 'object' && !Array.isArray(object)) {
        for (const [key, value] of Object.entries(object)) {
            if (value === null)
                Reflect.deleteProperty(object, key);
        }
    }
    return object;
}
/**
 * Creates a standard request ID (same as Platform).
 */
function uniqueKeyToRequestId(uniqueKey) {
    const str = (0, node_crypto_1.createHash)('sha256')
        .update(uniqueKey)
        .digest('base64')
        .replace(/(\+|\/|=)/g, '');
    return str.length > consts_1.REQUEST_ID_LENGTH ? str.slice(0, consts_1.REQUEST_ID_LENGTH) : str;
}
function isBuffer(value) {
    try {
        shapeshift_1.s.union(shapeshift_1.s.instance(Buffer), shapeshift_1.s.instance(ArrayBuffer), shapeshift_1.s.typedArray()).parse(value);
        return true;
    }
    catch {
        return false;
    }
}
function isStream(value) {
    return (typeof value === 'object' &&
        value &&
        ['on', 'pipe'].every((key) => key in value && typeof value[key] === 'function'));
}
exports.memoryStorageLog = log_1.default.child({ prefix: 'MemoryStorage' });
/**
 * Creates a hybrid Promise + AsyncIterable for offset-based pagination (Dataset.listItems).
 *
 * The returned object can be:
 * - Awaited directly to get the first page (backward compatible)
 * - Used with `for await...of` to iterate through all items
 */
function createPaginatedList(getPage, options = {}) {
    const offset = options.offset ?? 0;
    // Immediately fetch the first page (Infinity is used when no limit, gets clamped by Math.min downstream)
    const firstPagePromise = getPage(offset, options.limit ?? Infinity);
    async function* asyncGenerator() {
        let currentPage = await firstPagePromise;
        yield* currentPage.items;
        const limit = Math.min(options.limit ?? currentPage.total, currentPage.total);
        let currentOffset = offset + currentPage.items.length;
        let remainingItems = Math.min(currentPage.total - offset, limit) - currentPage.items.length;
        while (currentPage.items.length > 0 && // Continue only if at least some items were returned in the last page.
            remainingItems > 0) {
            currentPage = await getPage(currentOffset, remainingItems);
            yield* currentPage.items;
            currentOffset += currentPage.items.length;
            remainingItems -= currentPage.items.length;
        }
    }
    return Object.defineProperty(firstPagePromise, Symbol.asyncIterator, {
        value: asyncGenerator,
    });
}
/**
 * Creates a hybrid Promise + AsyncIterable for cursor-based pagination (KeyValueStore.listKeys).
 *
 * The returned object can be:
 * - Awaited directly to get the first page (backward compatible)
 * - Used with `for await...of` to iterate through all keys
 */
function createKeyList(getPage, options = {}) {
    // Immediately fetch the first page
    const firstPagePromise = getPage(options.exclusiveStartKey);
    async function* asyncGenerator() {
        let currentPage = await firstPagePromise;
        yield* currentPage.items;
        let remainingItems = options.limit ? options.limit - currentPage.items.length : undefined;
        while (currentPage.items.length > 0 &&
            currentPage.nextExclusiveStartKey !== undefined &&
            (remainingItems === undefined || remainingItems > 0)) {
            currentPage = await getPage(currentPage.nextExclusiveStartKey);
            yield* currentPage.items;
            if (remainingItems !== undefined) {
                remainingItems -= currentPage.items.length;
            }
        }
    }
    return Object.defineProperty(firstPagePromise, Symbol.asyncIterator, {
        value: asyncGenerator,
    });
}
/**
 * Creates a hybrid Promise + AsyncIterable that yields only key strings (KeyValueStore.keys).
 *
 * The returned object can be:
 * - Awaited directly to get the first page (backward compatible)
 * - Used with `for await...of` to iterate through all key strings
 */
function createKeyStringList(getPage, options = {}) {
    // Immediately fetch the first page
    const firstPagePromise = getPage(options.exclusiveStartKey);
    async function* asyncGenerator() {
        let currentPage = await firstPagePromise;
        for (const item of currentPage.items) {
            yield item.key;
        }
        let remainingItems = options.limit ? options.limit - currentPage.items.length : undefined;
        while (currentPage.items.length > 0 &&
            currentPage.nextExclusiveStartKey !== undefined &&
            (remainingItems === undefined || remainingItems > 0)) {
            currentPage = await getPage(currentPage.nextExclusiveStartKey);
            for (const item of currentPage.items) {
                yield item.key;
            }
            if (remainingItems !== undefined) {
                remainingItems -= currentPage.items.length;
            }
        }
    }
    return Object.defineProperty(firstPagePromise, Symbol.asyncIterator, {
        value: asyncGenerator,
    });
}
/**
 * Creates a hybrid Promise + AsyncIterable for offset-based pagination with index-value entries (Dataset.listEntries).
 *
 * The returned object can be:
 * - Awaited directly to get the first page with [index, item] tuples (backward compatible)
 * - Used with `for await...of` to iterate through all entries as [index, item] tuples
 */
function createPaginatedEntryList(getPage, options = {}) {
    const offset = options.offset ?? 0;
    // Immediately fetch the first page and transform items to entries
    const firstPagePromise = getPage(offset, options.limit ?? Infinity).then((result) => ({
        ...result,
        items: result.items.map((item, i) => [offset + i, item]),
    }));
    async function* asyncGenerator() {
        let currentIndex = offset;
        for await (const item of createPaginatedList(getPage, options)) {
            yield [currentIndex++, item];
        }
    }
    return Object.defineProperty(firstPagePromise, Symbol.asyncIterator, {
        value: asyncGenerator,
    });
}
//# sourceMappingURL=utils.js.map